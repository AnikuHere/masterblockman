/* This file is generated by tdr. */
/* No manual modification is permitted. */

/* metalib version: 1 */
/* metalib md5sum: 65d0301c457c17200214e2e089e79aee */

/* creation time: Fri Apr 28 09:43:21 2023 */
/* tdr version: 2.5.0, build at 20111124 */


using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using tsf4g_tdr_csharp;

namespace BattleProtocol
{


public enum  CS_MAIN_MSGID
{
        CS_MSG_MAIN_LOGIN = 0, // 登录服务器
        CS_MSG_MAIN_LOGIC = 1, // 逻辑服务器
        CS_MSG_MAIN_BATTLE = 2, // 战斗服务器
}
public enum  CS_SUB_MSGID_BATTLESVR
{
        CS_SUB_MSGID_BATTLESVR_LOGIN_REQ = 1, // 登陆请求
        CS_SUB_MSGID_BATTLESVR_LOGIN_RSP = 2, // 登陆回包
        CS_SUB_MSGID_MAPLOAD_PROGRESS_REQ = 4, // 地图加载进度上报
        CS_SUB_MSGID_MAPLOAD_PROGRESS_NOTIFY = 5, // 地图加载进度通知
        CS_SUB_MSGID_BATTLESVR_FINISH_LOADMAP_REQ = 6, // 完成地图加载消息上报
        CS_SUB_MSGID_BATTLESVR_GAMESTART_NOTIFY = 7, // 开始游戏通知消广播
        CS_SUB_MSGID_BATTLESVR_GAMEEND_REQ = 8, // 游戏结束通知上报
        CS_SUB_MSGID_BATTLESVR_GAMEEND_NOTIFY = 9, // 游戏结束通知通知
        CS_SUB_MSGID_BATTLESVR_GAMERESTART_REQ = 10, // 重连请求服务器数据
        CS_SUB_MSGID_BATTLESVR_GAMERESTART_RSP = 11, // 重连请求服务器数据完成
        CS_SUB_MSGID_BATTLE_HEARTBEAT_REQ = 12, // 心跳包请求
        CS_SUB_MSGID_BATTLE_HEARTBEAT_RSP = 13, // 心跳包请求回复
        CS_SUB_MSGID_BATTLE_MAPEVENT_REQ = 15, // 战斗地图信息号请求
        CS_SUB_MSGID_BATTLE_MAPEVENT_RSP = 16, // 战斗地图信息号请求回包
        CS_SUB_MSGID_BATTLE_MAPEVENT_NOTIFY = 17, // 战斗地图信息号广播
        CS_SUB_MSGID_BATTLESVR_FRAME_REQ = 30, // 1帧指令请求
        CS_SUB_MSGID_BATTLESVR_FRAME_NOTIFY = 31, // 1帧指令通知
        CS_SUB_MSGID_MINIMAP_EVENT_REQ = 32, // 小地图事件请求
        CS_SUB_MSGID_MINIMAP_EVENT_NOTIFY = 33, // 小地图事件通知
        CS_SUB_MSGID_SURRENDER_REQ = 34, // 投降请求
        CS_SUB_MSGID_SURRENDER_AGREE = 36, // 同意投降
        CS_SUB_MSGID_SURRENDER_REFUSE = 37, // 拒绝投降
        CS_SUB_MSGID_SURRENDER_AGREE_NOTIFY = 38, // 同意投降通知
        CS_SUB_MSGID_SURRENDER_REFUSE_NOTIFY = 39, // 拒绝投降通知
        CS_SUB_MSGID_SURRENDER_NOTIFY = 40, // 投降请求通知
        CS_SUB_MSGID_SURRENDER_RESULT_NOTIFY = 41, // 投降结果通知
        CS_SUB_MSGID_FETCH_FRAME_DATA_REQ = 42, // 请求重连数据
        CS_SUB_MSGID_PLAYER_CONNECT_NOTIFY = 43, // 玩家上下线通知
        CS_SUB_MSGID_NEW_PLAYER_INFO = 50, // 新玩家加入
        CS_SUB_MSGID_GM_COMMAND = 900, // gm指令
        CS_SUB_MSGID_DUMP_INFO = 901, // 客户端dumpinfo
        CS_SUB_MSGID_DUMP_INFO_RET = 902, // 客户端dumpinfo校验结果
        CS_SUB_MSGID_REPLAY_SVR_NEW_BATTLE_REQ = 910, // 新的战斗
        CS_SUB_MSGID_REPLAY_SVR_FRAME_MD5_REQ = 911, // 帧md5
        CS_SUB_MSGID_REPLAY_SVR_BATTLE_RESULT_NOTIFY = 912, // 结果通知
        CS_SUB_MSGID_REPLAY_SVR_SURRENDER_RESULT_NOTIFY = 913, // 投降结果通知
        CS_SUB_MSGID_BATTLESVR_MAX = 1000, // MAX
}
public enum  ErrCodeDefine
{
        ERR_SUCCESS = 0, // 成功
        ERR_PARAM_INV = 1, // 参数错误
        ERR_POINTER_NULL = 2, // 指针为空
        ERR_BATTLESVR_MONEYNOTENUGH = 10, // 金钱不够
        ERR_BATTLESVR_LOGIN_FAILED_BATTLEFINISHED = 100, // 登录服务器，战斗已经结束
        ERR_BATTLESVR_CASTSKILL_COMMONERRO = 200, // 技能参数错误
        ERR_BATTLESVR_CASTSKILL_PARAMERROR = 201, // 技能参数错误
        ERR_BATTLESVR_CASTSKILL_SKILLLOCK = 202, // 技能未解锁
        ERR_BATTLESVR_CASTSKILL_COLINGDOWN = 203, // 技能CD冷却中
        ERR_BATTLESVR_CASTSKILL_DISTANCE_NOTENOUGH = 204, // 不满足释放距离
        ERR_BATTLESVR_CASTSKILL_CONSUME_NOTENOUGH = 205, // 技能消耗不足
        ERR_BATTLESVR_CASTSKILL_TARGET_INAVALID = 206, // 当前目标非法
        ERR_BATTLESVR_CASTSKILL_SELFSTATE_INAVALIABLE = 207, // 自身状态非法
        ERR_BATTLESVR_CASTSKILL_SELFSTATE_HPISFULL = 208, // 使用基础加血技能,当前自身血量已满
        ERR_BATTLESVR_CASTSKILL_AICLOSE = 209, // 服务器AI关闭
        ERR_BATTLESVR_CASTSKILL_SKILLBEFOREROLL = 210, // 技能处于前摇中
        ERR_BATTLESVR_CASTSKILL_INDEBUFF = 211, // 处于DEBUFF中无法释放
        ERR_BATTLESVR_CASTSKILL_AVATARSKILLNOTEQUIP = 212, // 变体技能未挂载
        ERR_BATTLESVR_CASTSKILL_MOVINGNOTCAST = 213, // 移动中普攻技能无法释放
        ERR_BATTLESVR_OPEQUIP_NOTFINDEQUIP = 300, // 找不到对应装备
        ERR_BATTLESVR_OPEQUIP_EQUIPBARFULL = 301, // 装备栏位不足
        ERR_SYSTEM_SERVER_OBJ_NULL = 10001, // 系统错误,服务器发现空指针
}
public enum  PlatformType
{
        EN_PLATFORMTYPE_NONE = 0, // 未知
        EN_PLATFORMTYPE_QQ = 1, // QQ
        EN_PLATFORMTYPE_WX = 2, // 微信
        EN_PLATFORMTYPE_GUEST = 3, // 游客模式
}
public enum  OSType
{
        OSTYPE_IOS = 1, // IOS
        OSTYPE_ANDROID = 2, // Android
        OSTYPE_WINDOWS = 3, // PC
}
public enum  LoginConnectType
{
        EN_LOGINRECONNECT_NONE = 0, // 正常登录
        EN_LOGINRECONNECT_FLASH = 1, // 闪断重连
        EN_LOGINRECONNECT_BREAK = 2, // 长断重连
}
public enum  BattleMode
{
        EN_BT_PVP = 1, // PVP
        EN_BT_PVE = 2, // PVE
        EN_BT_ALL = 3, // 所有战场
}
public enum  BattleVSMode
{
        BT_QUALIFYING_1V1 = 1, // BT_QUALIFYING_1V1
        BT_QUALIFYING_3V3 = 2, // BT_QUALIFYING_3V3
        BT_MATCH_1V1 = 3, // BT_MATCH_1V1
        BT_MATCH_3V3 = 4, // BT_MATCH_3V3
        BT_ROOM = 5, // BT_ROOM
        BT_PVC = 6, // BT_PVC
        BT_QUALIFYING_2V2 = 7, // BT_QUALIFYING_2V2
        BT_MATCH_2V2 = 8, // BT_MATCH_2V2
        BT_ALL = 9, // 所有战场
}
public enum  BattleEvilMatchTeamType
{
        TEAMTYPE_RED = 1, // 红方队伍
        TEAMTYPE_PURPLE = 3, // 紫方队伍
        TEAMTYPE_PINK = 5, // 粉方队伍
}
public enum  BattleJusticeMatchTeamType
{
        TEAMTYPE_BLUE = 2, // 蓝方队伍
        TEAMTYPE_GREEN = 4, // 绿方队伍
        TEAMTYPE_YELLOW = 6, // 黄方队伍
}
public enum  CSClientOpenFlag
{
        CS_CLENTOPENFLAG_SHOP = 0, // 商城
        CS_CLENTOPENFLAG_CHAT = 1, // 聊天
        CS_CLENTOPENFLAG_MAIL = 2, // 邮件
        CS_CLENTOPENFLAG_LIVE = 3, // 直播
        CS_CLENTOPENFLAG_REPLAYS = 4, // 录像回看
        CS_CLENTOPENFLAG_FRIEND = 5, // 好友
        CS_CLENTOPENFLAG_ACHIEVE = 6, // 成就
        CS_CLENTOPENFLAG_TASK = 7, // 任务
        CS_CLENTOPENFLAG_ACTIVITY = 8, // 活动
        CS_CLENTOPENFLAG_MAX = 9, // MAX
}
public enum  CSBattleGankKillEvent
{
        CS_GANK_KILLEVENT_NONE = 0, // 无
        CS_GANK_KILLEVENT_FIRST_BLOOD = 1, // 首杀
        CS_GANK_KILLEVENT_DOMINATING = 2, // 主宰战场
        CS_GANK_KILLEVENT_UNSTOPPABLE = 3, // 无人能挡
        CS_GANK_KILLEVENT_LEGENDARY = 4, // 王者再临
        CS_GANK_KILLEVENT_KILLENEMYHERO = 5, // 击杀英雄
}
public enum  CSBattleKillDogfaceEvent
{
        CS_KILLDOGFACEEVENT_NONE = 0, // 无
        CS_KILLDOGFACEEVENT_GODLIKE = 1, // 杀小兵超神(连续击杀)
}
public enum  BattleActorState
{
        EN_ACTORSTATE_FREEZE = 0, // 冻结状态
        EN_ACTORSTATE_ALIVE = 1, // 活着
        EN_ACTORSTATE_DEATH = 2, // 死亡
        EN_ACTORSTATE_RECYCLE = 3, // 死亡回收中，用于清理
}
public enum  BattleActorRevivalType
{
        EN_ACTORREVIVALTYPE_DEAD = 0, // 死亡复活
        EN_ACTORREVIVALTYPE_SKILL = 1, // 技能重生复活
}
public enum  SkillCastInputMode
{
        EN_SKILLINPUT_ACTOR = 0, // 朝着目标
        EN_SKILLINPUT_POS = 1, // 朝点
}
public enum  BattleStatisticsEventType
{
        BATTLEEVENTTYPE_KILLHERO = 1, // 击杀英雄 
        BATTLEEVENTTYPE_KILLMONSTER = 2, // 击杀野怪
        BATTLEEVENTTYPE_KILLDOGFACE = 3, // 击杀士兵
        BATTLEEVENTTYPE_BUILDMINE = 4, // 造矿
        BATTLEEVENTTYPE_KILLDRAGON = 5, // 杀大龙
        BATTLEEVENTTYPE_BUILDTOWER = 6, // 造塔
}
public enum  RoomStepType
{
        ROOM_STEP_BATTLEREADY = 1, // 战斗准备中
        ROOM_STEP_SELECTHERO = 2, // 选择英雄中
        ROOM_STEP_LOADINGMAP = 3, // 等待地图加载中
        ROOM_STEP_WAITING = 4, // 等待战斗开始
        ROOM_STEP_BATTLESTART = 5, // 战场已经开始
        ROOM_STEP_BATTLEEND = 6, // 战斗已经结束
        ROOM_STEP_NOTEXIST = 7, // 房间不存在
}
public enum  RoomPlayerrStepType
{
        ROOMPLAYER_STEP_MATCH_OK = 1, // 匹配到队伍
        ROOMPLAYER_STEP_BATTLEREADY = 2, // 点了战斗准备
        ROOMPLAYER_STEP_SELECTHEROEND = 3, // 已经选好英雄
        ROOMPLAYER_STEP_LOADINGMAP = 4, // 正在加载地图
        ROOMPLAYER_STEP_ENDLOADINGMAP = 5, // 加载地图完成
        ROOMPLAYER_STEP_BATTLESTART = 6, // 战场已经开始
        ROOMPLAYER_STEP_BATTLEEND = 7, // 战斗已经结束
}
public enum  EquipOpType
{
        EQUIPOPTYPE_ADD = 0, // 添加装备
        EQUIPOPTYPE_REMOVE = 1, // 移除装备
        EQUIPOPTYPE_SELL = 2, // 出售装备
}
public enum  CSBattleSystemType
{
        CSBATTLESYTEMTYPE_HEROFORMATIONPOS = 1, // 队伍英雄站位,0=居中,1=队伍前,默认=0
        CSBATTLESYTEMTYPE_NEARASSISTED = 2, // 普攻近战集火开关,0=关,1=开,默认=0
        CSBATTLESYTEMTYPE_FARASSISTED = 3, // 普攻远程集火开关,0=关,1=开,默认=0
        CSBATTLESYTEMTYPE_MUTEXTREATTYPE = 4, // 治疗目标方式,0=互斥治疗,1=不互斥治疗,默认=0
        CSBATTLESYTEMTYPE_KEEPDIS = 5, // 最小首次攻击距离,0=关,1=开,默认=1
        CSBATTLESYTEMTYPE_CTRSKILLTOMONSTER = 6, // 控制技能对野怪施放,0=关,1=开,默认=0
        CSBATTLESYTEMTYPE_TEAMGROUPREGIONMAX = 7, // 队伍区域距离最大范围,距离
        CSBATTLESYTEMTYPE_ESCAPEHPPRECENT = 8, // 士兵受攻击时主动后撤血量,距离
        CSBATTLESYTEMTYPE_MAX = 9, // 最大值
}
public enum  CSBattleEventType
{
        CSBATTLEEVENTTYPE_HOST_CTRL = 1, // 进入托管模式
}
public enum  CSBattleFrameEventType
{
        BATTLEFRAMEEVENT_ACTOR_CASTSKILL = 1, // 单位释放技能
        BATTLEFRAMEEVENT_ACTOR_SKILLEVENT = 2, // 单位技能释放事件
        BATTLEFRAMEEVENT_ACTOR_ADDSKILLPOINIT = 3, // 单位技能加点
        BATTLEFRAMEEVENT_ACTOR_EQUIPOP = 4, // 单位装备操作
        BATTLEFRAMEEVENT_BATTLE_STARTMOVE = 10, // 开始移动
        BATTLEFRAMEEVENT_BATTLE_STOPMOVE = 11, // 停止移动
        BATTLEFRAMEEVENT_BATTLE_JUMP = 12, // 跳跃
        BATTLEFRAMEEVENT_BATTLE_WALK = 13, // 设置走路状态
        BATTLEFRAMEEVENT_BATTLE_FACE_DIR = 14, // 玩家转向
        BATTLEFRAMEEVENT_BATTLE_TEAMCONFIG = 30, // 同步玩家游戏设置
        BATTLEFRAMEEVENT_BATTLE_EVENTNOTIFY = 31, // 游戏通用事件通知
        BATTLEFRAMEEVENT_BATTLE_SET_HOTBAR_INDEX = 32, // 切换快捷栏
        BATTLEFRAMEEVENT_BATTLE_SWAP_ITEM_SLOT = 33, // 物品栏交换
        BATTLEFRAMEEVENT_BATTLE_GM_CMD = 100, // gm指令
        BATTLEFRAMEEVENT_BATTLE_GM_SCALE_TIME_CMD = 101, // gm指令修改服务器时间缩放
        BATTLEFRAMEEVENT_BATTLE_GAME_END_NOTIFY = 102, // 服务器主动结束战斗通知
}
public enum  CSMiniMapEvent
{
        MINIMAPEVENT_NONE = 0,
        MINIMAPEVENT_STICKTOGETHER = 1, // 集合
        MINIMAPEVENT_WITHDRAW = 2, // 撤退
        MINIMAPEVENT_ATTACK = 3, // 进攻
}
public enum  GameReStartState
{
        GAMERESTARTSTATE_NONE = 0, // 未重连
        GAMERESTARTSTATE_SYNC = 1, // 同步中
        GAMERESTARTSTATE_QUEUED = 2, // 排队中
}


public class CSFlushMsgHead : tsf4g_csharp_interface
{
        /* public members */
        public UInt16  wDataLen; // 数据长度
        public UInt16  wLzoLen; // 压缩后的长度，为0表示未压缩

        /* construct methods */
        public CSFlushMsgHead()
        {
        }

        /* public methods */
        public TdrError.ErrorType construct()
        {
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /*no need to  set defaultvalue */

                return ret;
        }

        public TdrError.ErrorType pack(ref byte[] buffer, int size,ref int usedSize , uint cutVer)
        {
                if (null == buffer || 0 == buffer.GetLength(0) || (size > buffer.GetLength(0)))
                {
                    return TdrError.ErrorType.TDR_ERR_INVALID_BUFFER_PARAMETER;
                }

                TdrWriteBuf destBuf = new TdrWriteBuf(ref buffer, size);
                TdrError.ErrorType ret = pack(ref destBuf, cutVer);
                if (ret == TdrError.ErrorType.TDR_NO_ERROR)
                {
                        buffer = destBuf.getBeginPtr();

                        usedSize = destBuf.getUsedSize();
                }

                return ret;
        }

        public TdrError.ErrorType pack(ref TdrWriteBuf destBuf,  uint cutVer)
        {
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /* adjust cutversion */
                if (0 == cutVer || CSFlushMsgHead.CURRVERSION < cutVer)
                {
                        cutVer = CSFlushMsgHead.CURRVERSION;
                }

                /* check cutversion */
                if (CSFlushMsgHead.BASEVERSION > cutVer)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return TdrError.ErrorType.TDR_ERR_CUTVER_TOO_SMALL;
                }

                /* pack member: this.wDataLen */
                {
                        ret = destBuf.writeUInt16(this.wDataLen);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
#if (DEBUG)
                                StackTrace st = new StackTrace(true);
                                for (int i = 0; i < st.FrameCount; i++)
                                {
                                        if (null != st.GetFrame(i).GetFileName())
                                        {
                                                Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                        }
                                }
#endif
                                return ret;
                        }
                }

                /* pack member: this.wLzoLen */
                {
                        ret = destBuf.writeUInt16(this.wLzoLen);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
#if (DEBUG)
                                StackTrace st = new StackTrace(true);
                                for (int i = 0; i < st.FrameCount; i++)
                                {
                                        if (null != st.GetFrame(i).GetFileName())
                                        {
                                                Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                        }
                                }
#endif
                                return ret;
                        }
                }

                return ret;
        }

        public TdrError.ErrorType unpack(ref byte [] buffer, int size, ref int usedSize , uint cutVer)
        {
                if (null == buffer || 0 == buffer.GetLength(0) || size > buffer.GetLength(0))
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                    return TdrError.ErrorType.TDR_ERR_INVALID_BUFFER_PARAMETER;
                }

                TdrReadBuf srcBuf = new TdrReadBuf(ref buffer, size);
                TdrError.ErrorType ret = unpack(ref srcBuf, cutVer);

                usedSize = srcBuf.getUsedSize();

                return ret;
        }

        public TdrError.ErrorType unpack(ref TdrReadBuf srcBuf, uint cutVer)
        {
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /* adjust cutversion */
                if (0 == cutVer || CSFlushMsgHead.CURRVERSION < cutVer)
                {
                        cutVer = CSFlushMsgHead.CURRVERSION;
                }

                /* check cutversion */
                if (CSFlushMsgHead.BASEVERSION > cutVer)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return TdrError.ErrorType.TDR_ERR_CUTVER_TOO_SMALL;
                }

                /* unpack member: this.wDataLen */
                {
                        ret = srcBuf.readUInt16(ref this.wDataLen);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
                                return ret;
                        }
                }

                /* unpack member: this.wLzoLen */
                {
                        ret = srcBuf.readUInt16(ref this.wLzoLen);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
                                return ret;
                        }
                }

                return ret;
        }

        public TdrError.ErrorType load(ref byte [] buffer, int size, ref int usedSize , uint cutVer)
        {
                if (null == buffer || 0 == buffer.GetLength(0) || size > buffer.GetLength(0))
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                    return TdrError.ErrorType.TDR_ERR_INVALID_BUFFER_PARAMETER;
                }

                TdrReadBuf srcBuf = new TdrReadBuf(ref buffer, size);
                TdrError.ErrorType ret = load(ref srcBuf, cutVer);

                usedSize = srcBuf.getUsedSize();

                return ret;
        }

        public TdrError.ErrorType load(ref TdrReadBuf srcBuf, uint cutVer)
        {
                srcBuf.disableEndian();
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /* adjust cutversion */
                if (0 == cutVer || CSFlushMsgHead.CURRVERSION < cutVer)
                {
                        cutVer = CSFlushMsgHead.CURRVERSION;
                }

                /* check cutversion */
                if (CSFlushMsgHead.BASEVERSION > cutVer)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return TdrError.ErrorType.TDR_ERR_CUTVER_TOO_SMALL;
                }

                /* load member: this.wDataLen */
                {
                        ret = srcBuf.readUInt16(ref this.wDataLen);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
                                return ret;
                        }
                }

                /* load member: this.wLzoLen */
                {
                        ret = srcBuf.readUInt16(ref this.wLzoLen);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
                                return ret;
                        }
                }

                return ret;
        }

        /* set indent = -1 to disable indent , default: separator = '\n' */
        public TdrError.ErrorType visualize(ref string buffer,int indent , char separator)
        {
                TdrVisualBuf destBuf = new TdrVisualBuf();
                TdrError.ErrorType ret = visualize(ref destBuf, indent, separator);

                buffer = destBuf.getVisualBuf();

                return ret;
        }

        /* set indent = -1 to disable indent , default: separator = '\n' */
        public TdrError.ErrorType visualize(ref TdrVisualBuf destBuf, int indent, char separator)
        {
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /* visualize member: this.wDataLen */
                ret = TdrBufUtil.printVariable(ref destBuf, indent, separator, "[wDataLen]", "{0:d}", this.wDataLen);
                if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return ret;
                }

                /* visualize member: this.wLzoLen */
                ret = TdrBufUtil.printVariable(ref destBuf, indent, separator, "[wLzoLen]", "{0:d}", this.wLzoLen);
                if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return ret;
                }

                return ret;
        }

        public TdrError.ErrorType getSizeInfo(byte[] buffer ,int size , ref uint sizeInfo)
        {
                if (0 == buffer.GetLength(0) || size > buffer.GetLength(0))
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                    return TdrError.ErrorType.TDR_ERR_INVALID_BUFFER_PARAMETER;
                }

                TdrReadBuf srcBuf = new TdrReadBuf(ref buffer, size);
                TdrError.ErrorType ret = getSizeInfo(srcBuf, ref sizeInfo);

                return ret;
        }

        public TdrError.ErrorType getSizeInfo(TdrReadBuf srcBuf, ref uint sizeInfo)
        {
                return TdrError.ErrorType.TDR_ERR_HAVE_NOT_SET_SIZEINFO;
        }

        /*  pstMeta version info */
        public static readonly uint BASEVERSION = 1;
        public static readonly uint CURRVERSION = 1;
        /*  entry version info */
}


public class CSMsgHead : tsf4g_csharp_interface
{
        /* public members */
        public Int32  iFrame; // 帧号
        public UInt16  wSubMsgID; // 子协议编号

        /* construct methods */
        public CSMsgHead()
        {
        }

        /* public methods */
        public TdrError.ErrorType construct()
        {
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /*no need to  set defaultvalue */

                return ret;
        }

        public TdrError.ErrorType pack(ref byte[] buffer, int size,ref int usedSize , uint cutVer)
        {
                if (null == buffer || 0 == buffer.GetLength(0) || (size > buffer.GetLength(0)))
                {
                    return TdrError.ErrorType.TDR_ERR_INVALID_BUFFER_PARAMETER;
                }

                TdrWriteBuf destBuf = new TdrWriteBuf(ref buffer, size);
                TdrError.ErrorType ret = pack(ref destBuf, cutVer);
                if (ret == TdrError.ErrorType.TDR_NO_ERROR)
                {
                        buffer = destBuf.getBeginPtr();

                        usedSize = destBuf.getUsedSize();
                }

                return ret;
        }

        public TdrError.ErrorType pack(ref TdrWriteBuf destBuf,  uint cutVer)
        {
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /* adjust cutversion */
                if (0 == cutVer || CSMsgHead.CURRVERSION < cutVer)
                {
                        cutVer = CSMsgHead.CURRVERSION;
                }

                /* check cutversion */
                if (CSMsgHead.BASEVERSION > cutVer)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return TdrError.ErrorType.TDR_ERR_CUTVER_TOO_SMALL;
                }

                /* pack member: this.iFrame */
                {
                        ret = destBuf.writeInt32(this.iFrame);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
#if (DEBUG)
                                StackTrace st = new StackTrace(true);
                                for (int i = 0; i < st.FrameCount; i++)
                                {
                                        if (null != st.GetFrame(i).GetFileName())
                                        {
                                                Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                        }
                                }
#endif
                                return ret;
                        }
                }

                /* pack member: this.wSubMsgID */
                {
                        ret = destBuf.writeUInt16(this.wSubMsgID);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
#if (DEBUG)
                                StackTrace st = new StackTrace(true);
                                for (int i = 0; i < st.FrameCount; i++)
                                {
                                        if (null != st.GetFrame(i).GetFileName())
                                        {
                                                Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                        }
                                }
#endif
                                return ret;
                        }
                }

                return ret;
        }

        public TdrError.ErrorType unpack(ref byte [] buffer, int size, ref int usedSize , uint cutVer)
        {
                if (null == buffer || 0 == buffer.GetLength(0) || size > buffer.GetLength(0))
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                    return TdrError.ErrorType.TDR_ERR_INVALID_BUFFER_PARAMETER;
                }

                TdrReadBuf srcBuf = new TdrReadBuf(ref buffer, size);
                TdrError.ErrorType ret = unpack(ref srcBuf, cutVer);

                usedSize = srcBuf.getUsedSize();

                return ret;
        }

        public TdrError.ErrorType unpack(ref TdrReadBuf srcBuf, uint cutVer)
        {
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /* adjust cutversion */
                if (0 == cutVer || CSMsgHead.CURRVERSION < cutVer)
                {
                        cutVer = CSMsgHead.CURRVERSION;
                }

                /* check cutversion */
                if (CSMsgHead.BASEVERSION > cutVer)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return TdrError.ErrorType.TDR_ERR_CUTVER_TOO_SMALL;
                }

                /* unpack member: this.iFrame */
                {
                        ret = srcBuf.readInt32(ref this.iFrame);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
                                return ret;
                        }
                }

                /* unpack member: this.wSubMsgID */
                {
                        ret = srcBuf.readUInt16(ref this.wSubMsgID);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
                                return ret;
                        }
                }

                return ret;
        }

        public TdrError.ErrorType load(ref byte [] buffer, int size, ref int usedSize , uint cutVer)
        {
                if (null == buffer || 0 == buffer.GetLength(0) || size > buffer.GetLength(0))
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                    return TdrError.ErrorType.TDR_ERR_INVALID_BUFFER_PARAMETER;
                }

                TdrReadBuf srcBuf = new TdrReadBuf(ref buffer, size);
                TdrError.ErrorType ret = load(ref srcBuf, cutVer);

                usedSize = srcBuf.getUsedSize();

                return ret;
        }

        public TdrError.ErrorType load(ref TdrReadBuf srcBuf, uint cutVer)
        {
                srcBuf.disableEndian();
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /* adjust cutversion */
                if (0 == cutVer || CSMsgHead.CURRVERSION < cutVer)
                {
                        cutVer = CSMsgHead.CURRVERSION;
                }

                /* check cutversion */
                if (CSMsgHead.BASEVERSION > cutVer)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return TdrError.ErrorType.TDR_ERR_CUTVER_TOO_SMALL;
                }

                /* load member: this.iFrame */
                {
                        ret = srcBuf.readInt32(ref this.iFrame);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
                                return ret;
                        }
                }

                /* load member: this.wSubMsgID */
                {
                        ret = srcBuf.readUInt16(ref this.wSubMsgID);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
                                return ret;
                        }
                }

                return ret;
        }

        /* set indent = -1 to disable indent , default: separator = '\n' */
        public TdrError.ErrorType visualize(ref string buffer,int indent , char separator)
        {
                TdrVisualBuf destBuf = new TdrVisualBuf();
                TdrError.ErrorType ret = visualize(ref destBuf, indent, separator);

                buffer = destBuf.getVisualBuf();

                return ret;
        }

        /* set indent = -1 to disable indent , default: separator = '\n' */
        public TdrError.ErrorType visualize(ref TdrVisualBuf destBuf, int indent, char separator)
        {
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /* visualize member: this.iFrame */
                ret = TdrBufUtil.printVariable(ref destBuf, indent, separator, "[iFrame]", "{0:d}", this.iFrame);
                if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return ret;
                }

                /* visualize member: this.wSubMsgID */
                ret = TdrBufUtil.printVariable(ref destBuf, indent, separator, "[wSubMsgID]", "{0:d}", this.wSubMsgID);
                if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return ret;
                }

                return ret;
        }

        public TdrError.ErrorType getSizeInfo(byte[] buffer ,int size , ref uint sizeInfo)
        {
                if (0 == buffer.GetLength(0) || size > buffer.GetLength(0))
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                    return TdrError.ErrorType.TDR_ERR_INVALID_BUFFER_PARAMETER;
                }

                TdrReadBuf srcBuf = new TdrReadBuf(ref buffer, size);
                TdrError.ErrorType ret = getSizeInfo(srcBuf, ref sizeInfo);

                return ret;
        }

        public TdrError.ErrorType getSizeInfo(TdrReadBuf srcBuf, ref uint sizeInfo)
        {
                return TdrError.ErrorType.TDR_ERR_HAVE_NOT_SET_SIZEINFO;
        }

        /*  pstMeta version info */
        public static readonly uint BASEVERSION = 1;
        public static readonly uint CURRVERSION = 1;
        /*  entry version info */
}


public class CSUpMsgHead : tsf4g_csharp_interface
{
        /* public members */
        public UInt16  wSubMsgID; // 子协议编号

        /* construct methods */
        public CSUpMsgHead()
        {
        }

        /* public methods */
        public TdrError.ErrorType construct()
        {
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /*no need to  set defaultvalue */

                return ret;
        }

        public TdrError.ErrorType pack(ref byte[] buffer, int size,ref int usedSize , uint cutVer)
        {
                if (null == buffer || 0 == buffer.GetLength(0) || (size > buffer.GetLength(0)))
                {
                    return TdrError.ErrorType.TDR_ERR_INVALID_BUFFER_PARAMETER;
                }

                TdrWriteBuf destBuf = new TdrWriteBuf(ref buffer, size);
                TdrError.ErrorType ret = pack(ref destBuf, cutVer);
                if (ret == TdrError.ErrorType.TDR_NO_ERROR)
                {
                        buffer = destBuf.getBeginPtr();

                        usedSize = destBuf.getUsedSize();
                }

                return ret;
        }

        public TdrError.ErrorType pack(ref TdrWriteBuf destBuf,  uint cutVer)
        {
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /* adjust cutversion */
                if (0 == cutVer || CSUpMsgHead.CURRVERSION < cutVer)
                {
                        cutVer = CSUpMsgHead.CURRVERSION;
                }

                /* check cutversion */
                if (CSUpMsgHead.BASEVERSION > cutVer)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return TdrError.ErrorType.TDR_ERR_CUTVER_TOO_SMALL;
                }

                /* pack member: this.wSubMsgID */
                {
                        ret = destBuf.writeUInt16(this.wSubMsgID);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
#if (DEBUG)
                                StackTrace st = new StackTrace(true);
                                for (int i = 0; i < st.FrameCount; i++)
                                {
                                        if (null != st.GetFrame(i).GetFileName())
                                        {
                                                Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                        }
                                }
#endif
                                return ret;
                        }
                }

                return ret;
        }

        public TdrError.ErrorType unpack(ref byte [] buffer, int size, ref int usedSize , uint cutVer)
        {
                if (null == buffer || 0 == buffer.GetLength(0) || size > buffer.GetLength(0))
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                    return TdrError.ErrorType.TDR_ERR_INVALID_BUFFER_PARAMETER;
                }

                TdrReadBuf srcBuf = new TdrReadBuf(ref buffer, size);
                TdrError.ErrorType ret = unpack(ref srcBuf, cutVer);

                usedSize = srcBuf.getUsedSize();

                return ret;
        }

        public TdrError.ErrorType unpack(ref TdrReadBuf srcBuf, uint cutVer)
        {
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /* adjust cutversion */
                if (0 == cutVer || CSUpMsgHead.CURRVERSION < cutVer)
                {
                        cutVer = CSUpMsgHead.CURRVERSION;
                }

                /* check cutversion */
                if (CSUpMsgHead.BASEVERSION > cutVer)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return TdrError.ErrorType.TDR_ERR_CUTVER_TOO_SMALL;
                }

                /* unpack member: this.wSubMsgID */
                {
                        ret = srcBuf.readUInt16(ref this.wSubMsgID);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
                                return ret;
                        }
                }

                return ret;
        }

        public TdrError.ErrorType load(ref byte [] buffer, int size, ref int usedSize , uint cutVer)
        {
                if (null == buffer || 0 == buffer.GetLength(0) || size > buffer.GetLength(0))
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                    return TdrError.ErrorType.TDR_ERR_INVALID_BUFFER_PARAMETER;
                }

                TdrReadBuf srcBuf = new TdrReadBuf(ref buffer, size);
                TdrError.ErrorType ret = load(ref srcBuf, cutVer);

                usedSize = srcBuf.getUsedSize();

                return ret;
        }

        public TdrError.ErrorType load(ref TdrReadBuf srcBuf, uint cutVer)
        {
                srcBuf.disableEndian();
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /* adjust cutversion */
                if (0 == cutVer || CSUpMsgHead.CURRVERSION < cutVer)
                {
                        cutVer = CSUpMsgHead.CURRVERSION;
                }

                /* check cutversion */
                if (CSUpMsgHead.BASEVERSION > cutVer)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return TdrError.ErrorType.TDR_ERR_CUTVER_TOO_SMALL;
                }

                /* load member: this.wSubMsgID */
                {
                        ret = srcBuf.readUInt16(ref this.wSubMsgID);
                        if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                        {
                                return ret;
                        }
                }

                return ret;
        }

        /* set indent = -1 to disable indent , default: separator = '\n' */
        public TdrError.ErrorType visualize(ref string buffer,int indent , char separator)
        {
                TdrVisualBuf destBuf = new TdrVisualBuf();
                TdrError.ErrorType ret = visualize(ref destBuf, indent, separator);

                buffer = destBuf.getVisualBuf();

                return ret;
        }

        /* set indent = -1 to disable indent , default: separator = '\n' */
        public TdrError.ErrorType visualize(ref TdrVisualBuf destBuf, int indent, char separator)
        {
                TdrError.ErrorType ret = TdrError.ErrorType.TDR_NO_ERROR;

                /* visualize member: this.wSubMsgID */
                ret = TdrBufUtil.printVariable(ref destBuf, indent, separator, "[wSubMsgID]", "{0:d}", this.wSubMsgID);
                if (TdrError.ErrorType.TDR_NO_ERROR != ret)
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                        return ret;
                }

                return ret;
        }

        public TdrError.ErrorType getSizeInfo(byte[] buffer ,int size , ref uint sizeInfo)
        {
                if (0 == buffer.GetLength(0) || size > buffer.GetLength(0))
                {
#if (DEBUG)
                        StackTrace st = new StackTrace(true);
                        for (int i = 0; i < st.FrameCount; i++)
                        {
                                if (null != st.GetFrame(i).GetFileName())
                                {
                                        Console.WriteLine("TSF4G_TRACE:  " + st.GetFrame(i).ToString());
                                }
                        }
#endif
                    return TdrError.ErrorType.TDR_ERR_INVALID_BUFFER_PARAMETER;
                }

                TdrReadBuf srcBuf = new TdrReadBuf(ref buffer, size);
                TdrError.ErrorType ret = getSizeInfo(srcBuf, ref sizeInfo);

                return ret;
        }

        public TdrError.ErrorType getSizeInfo(TdrReadBuf srcBuf, ref uint sizeInfo)
        {
                return TdrError.ErrorType.TDR_ERR_HAVE_NOT_SET_SIZEINFO;
        }

        /*  pstMeta version info */
        public static readonly uint BASEVERSION = 1;
        public static readonly uint CURRVERSION = 1;
        /*  entry version info */
}


}
