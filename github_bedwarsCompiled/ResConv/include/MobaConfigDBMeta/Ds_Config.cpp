/* This file is generated by tdr. */
/* No manual modification is permitted. */

/* metalib version: 1 */
/* metalib md5sum: 0fb322fb7d0670d0d2485340276272fa */

/* creation time: Fri Apr 28 11:11:00 2023 */
/* tdr version: 2.5.0, build at 20111124 */

#include "Ds_Config.h"
#include "TdrTypeUtil.h"

using tsf4g_tdr::TdrBufUtil;
using tsf4g_tdr::TdrTypeUtil;

namespace MobaConfigDBMeta
{


TdrError::ErrorType
PvpSpawnEventCfg::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
PvpSpawnEventCfg::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
PvpSpawnEventCfg::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || PvpSpawnEventCfg::CURRVERSION < cutVer)
    {
        cutVer = PvpSpawnEventCfg::CURRVERSION;
    }

    /* check cutversion */
    if (PvpSpawnEventCfg::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->EventID */
    {
        ret = destBuf.writeInt32(this->EventID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->Param1 */
    {
        ret = destBuf.writeInt32(this->Param1);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->Param2 */
    {
        ret = destBuf.writeInt32(this->Param2);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->Param3 */
    {
        ret = destBuf.writeInt32(this->Param3);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->Param4 */
    {
        ret = destBuf.writeInt32(this->Param4);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
PvpSpawnEventCfg::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
PvpSpawnEventCfg::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || PvpSpawnEventCfg::CURRVERSION < cutVer)
    {
        cutVer = PvpSpawnEventCfg::CURRVERSION;
    }

    /* check cutversion */
    if (PvpSpawnEventCfg::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->EventID */
    {
        ret = srcBuf.readInt32(this->EventID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->Param1 */
    {
        ret = srcBuf.readInt32(this->Param1);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->Param2 */
    {
        ret = srcBuf.readInt32(this->Param2);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->Param3 */
    {
        ret = srcBuf.readInt32(this->Param3);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->Param4 */
    {
        ret = srcBuf.readInt32(this->Param4);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
PvpSpawnEventCfg::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
PvpSpawnEventCfg::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->EventID */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[EventID]", "%d", this->EventID);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->Param1 */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Param1]", "%d", this->Param1);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->Param2 */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Param2]", "%d", this->Param2);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->Param3 */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Param3]", "%d", this->Param3);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->Param4 */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Param4]", "%d", this->Param4);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    return ret;
}

const char*
PvpSpawnEventCfg::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
PvpSpawnEventCfg::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
MobaVector3::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
MobaVector3::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MobaVector3::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || MobaVector3::CURRVERSION < cutVer)
    {
        cutVer = MobaVector3::CURRVERSION;
    }

    /* check cutversion */
    if (MobaVector3::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->X */
    {
        ret = destBuf.writeInt32(this->X);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->Y */
    {
        ret = destBuf.writeInt32(this->Y);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->Z */
    {
        ret = destBuf.writeInt32(this->Z);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
MobaVector3::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MobaVector3::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || MobaVector3::CURRVERSION < cutVer)
    {
        cutVer = MobaVector3::CURRVERSION;
    }

    /* check cutversion */
    if (MobaVector3::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->X */
    {
        ret = srcBuf.readInt32(this->X);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->Y */
    {
        ret = srcBuf.readInt32(this->Y);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->Z */
    {
        ret = srcBuf.readInt32(this->Z);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
MobaVector3::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MobaVector3::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->X */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[X]", "%d", this->X);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->Y */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Y]", "%d", this->Y);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->Z */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Z]", "%d", this->Z);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    return ret;
}

const char*
MobaVector3::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
MobaVector3::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
PathConfig::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
PathConfig::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
PathConfig::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || PathConfig::CURRVERSION < cutVer)
    {
        cutVer = PathConfig::CURRVERSION;
    }

    /* check cutversion */
    if (PathConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->ID */
    {
        ret = destBuf.writeInt32(this->ID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->PositionCnt */
    {
        ret = destBuf.writeInt32(this->PositionCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->PositionList */
    {
        for (unsigned PositionList_i = 0; PositionList_i < RES_PVPCONFIG_MAX_PATHPOINT_LEN; PositionList_i++)
        {
            ret = this->PositionList[PositionList_i].pack(destBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
PathConfig::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
PathConfig::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || PathConfig::CURRVERSION < cutVer)
    {
        cutVer = PathConfig::CURRVERSION;
    }

    /* check cutversion */
    if (PathConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->ID */
    {
        ret = srcBuf.readInt32(this->ID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->PositionCnt */
    {
        ret = srcBuf.readInt32(this->PositionCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->PositionList */
    {
        for (unsigned PositionList_i = 0; PositionList_i < RES_PVPCONFIG_MAX_PATHPOINT_LEN; PositionList_i++)
        {
            ret = this->PositionList[PositionList_i].unpack(srcBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
PathConfig::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
PathConfig::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->ID */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[ID]", "%d", this->ID);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->PositionCnt */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[PositionCnt]", "%d", this->PositionCnt);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->PositionList */
    for (unsigned PositionList_i = 0; PositionList_i < RES_PVPCONFIG_MAX_PATHPOINT_LEN; PositionList_i++)
    {
        ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[PositionList]", PositionList_i, true);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }

        /* visualize children of this->PositionList[PositionList_i] */
        if (0 > indent)
        {
            ret = this->PositionList[PositionList_i].visualize(destBuf, indent, separator);
        } else
        {
            ret = this->PositionList[PositionList_i].visualize(destBuf, indent + 1, separator);
        }
        if (TdrError::TDR_NO_ERROR != ret)
        {
            return ret;
        }
    }

    return ret;
}

const char*
PathConfig::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
PathConfig::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
ItemDropsOneCond::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
ItemDropsOneCond::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
ItemDropsOneCond::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || ItemDropsOneCond::CURRVERSION < cutVer)
    {
        cutVer = ItemDropsOneCond::CURRVERSION;
    }

    /* check cutversion */
    if (ItemDropsOneCond::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->Random */
    {
        ret = destBuf.writeInt32(this->Random);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->DropType */
    {
        ret = destBuf.writeInt8(this->DropType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->FixedItemResID */
    {
        ret = destBuf.writeInt32(this->FixedItemResID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->RandomItemLv */
    {
        ret = destBuf.writeInt8(this->RandomItemLv);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->RandomItemType */
    {
        ret = destBuf.writeInt8(this->RandomItemType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
ItemDropsOneCond::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
ItemDropsOneCond::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || ItemDropsOneCond::CURRVERSION < cutVer)
    {
        cutVer = ItemDropsOneCond::CURRVERSION;
    }

    /* check cutversion */
    if (ItemDropsOneCond::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->Random */
    {
        ret = srcBuf.readInt32(this->Random);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->DropType */
    {
        ret = srcBuf.readInt8(this->DropType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->FixedItemResID */
    {
        ret = srcBuf.readInt32(this->FixedItemResID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->RandomItemLv */
    {
        ret = srcBuf.readInt8(this->RandomItemLv);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->RandomItemType */
    {
        ret = srcBuf.readInt8(this->RandomItemType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
ItemDropsOneCond::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
ItemDropsOneCond::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->Random */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Random]", "%d", this->Random);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->DropType */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[DropType]", "0x%02x", this->DropType);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->FixedItemResID */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[FixedItemResID]", "%d", this->FixedItemResID);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->RandomItemLv */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[RandomItemLv]", "0x%02x", this->RandomItemLv);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->RandomItemType */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[RandomItemType]", "0x%02x", this->RandomItemType);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    return ret;
}

const char*
ItemDropsOneCond::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
ItemDropsOneCond::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
ItemDropsOneConfig::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
ItemDropsOneConfig::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
ItemDropsOneConfig::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || ItemDropsOneConfig::CURRVERSION < cutVer)
    {
        cutVer = ItemDropsOneConfig::CURRVERSION;
    }

    /* check cutversion */
    if (ItemDropsOneConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->CondsCnt */
    {
        ret = destBuf.writeInt32(this->CondsCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->ItemDropsConds */
    {
        for (unsigned ItemDropsConds_i = 0; ItemDropsConds_i < RES_PVPCONFIG_DROPITEMCONDTION_NUM; ItemDropsConds_i++)
        {
            ret = this->ItemDropsConds[ItemDropsConds_i].pack(destBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
ItemDropsOneConfig::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
ItemDropsOneConfig::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || ItemDropsOneConfig::CURRVERSION < cutVer)
    {
        cutVer = ItemDropsOneConfig::CURRVERSION;
    }

    /* check cutversion */
    if (ItemDropsOneConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->CondsCnt */
    {
        ret = srcBuf.readInt32(this->CondsCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->ItemDropsConds */
    {
        for (unsigned ItemDropsConds_i = 0; ItemDropsConds_i < RES_PVPCONFIG_DROPITEMCONDTION_NUM; ItemDropsConds_i++)
        {
            ret = this->ItemDropsConds[ItemDropsConds_i].unpack(srcBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
ItemDropsOneConfig::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
ItemDropsOneConfig::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->CondsCnt */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[CondsCnt]", "%d", this->CondsCnt);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->ItemDropsConds */
    for (unsigned ItemDropsConds_i = 0; ItemDropsConds_i < RES_PVPCONFIG_DROPITEMCONDTION_NUM; ItemDropsConds_i++)
    {
        ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[ItemDropsConds]", ItemDropsConds_i, true);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }

        /* visualize children of this->ItemDropsConds[ItemDropsConds_i] */
        if (0 > indent)
        {
            ret = this->ItemDropsConds[ItemDropsConds_i].visualize(destBuf, indent, separator);
        } else
        {
            ret = this->ItemDropsConds[ItemDropsConds_i].visualize(destBuf, indent + 1, separator);
        }
        if (TdrError::TDR_NO_ERROR != ret)
        {
            return ret;
        }
    }

    return ret;
}

const char*
ItemDropsOneConfig::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
ItemDropsOneConfig::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
BatchConfig::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
BatchConfig::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
BatchConfig::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || BatchConfig::CURRVERSION < cutVer)
    {
        cutVer = BatchConfig::CURRVERSION;
    }

    /* check cutversion */
    if (BatchConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->DelayTime */
    {
        ret = destBuf.writeInt32(this->DelayTime);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->ResID */
    {
        ret = destBuf.writeInt32(this->ResID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->UseRaceResID */
    {
        ret = destBuf.writeInt8(this->UseRaceResID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->RaceResID */
    {
        for (unsigned RaceResID_i = 0; RaceResID_i < RES_PVPCONFIG_MAX_RACE_LEN; RaceResID_i++)
        {
            ret = destBuf.writeInt32(this->RaceResID[RaceResID_i]);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* pack member: this->Position */
    {
        ret = this->Position.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->Rotation */
    {
        ret = this->Rotation.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->SpawnPathID */
    {
        ret = destBuf.writeInt32(this->SpawnPathID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->ItemDropsCnt */
    {
        ret = destBuf.writeInt32(this->ItemDropsCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->ItemDropsList */
    {
        for (unsigned ItemDropsList_i = 0; ItemDropsList_i < RES_PVPCONFIG_DROPITEM_NUM; ItemDropsList_i++)
        {
            ret = this->ItemDropsList[ItemDropsList_i].pack(destBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
BatchConfig::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
BatchConfig::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || BatchConfig::CURRVERSION < cutVer)
    {
        cutVer = BatchConfig::CURRVERSION;
    }

    /* check cutversion */
    if (BatchConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->DelayTime */
    {
        ret = srcBuf.readInt32(this->DelayTime);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->ResID */
    {
        ret = srcBuf.readInt32(this->ResID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->UseRaceResID */
    {
        ret = srcBuf.readInt8(this->UseRaceResID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->RaceResID */
    {
        for (unsigned RaceResID_i = 0; RaceResID_i < RES_PVPCONFIG_MAX_RACE_LEN; RaceResID_i++)
        {
            ret = srcBuf.readInt32(this->RaceResID[RaceResID_i]);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* unpack member: this->Position */
    {
        ret = this->Position.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->Rotation */
    {
        ret = this->Rotation.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->SpawnPathID */
    {
        ret = srcBuf.readInt32(this->SpawnPathID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->ItemDropsCnt */
    {
        ret = srcBuf.readInt32(this->ItemDropsCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->ItemDropsList */
    {
        for (unsigned ItemDropsList_i = 0; ItemDropsList_i < RES_PVPCONFIG_DROPITEM_NUM; ItemDropsList_i++)
        {
            ret = this->ItemDropsList[ItemDropsList_i].unpack(srcBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
BatchConfig::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
BatchConfig::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->DelayTime */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[DelayTime]", "%d", this->DelayTime);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->ResID */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[ResID]", "%d", this->ResID);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->UseRaceResID */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[UseRaceResID]", "0x%02x", this->UseRaceResID);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->RaceResID */
    ret = TdrBufUtil::printArray(destBuf, indent, separator, "[RaceResID]", RES_PVPCONFIG_MAX_RACE_LEN);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }
    for (unsigned RaceResID_i = 0; RaceResID_i < RES_PVPCONFIG_MAX_RACE_LEN; RaceResID_i++)
    {
        ret = destBuf.textize(" ""%d", this->RaceResID[RaceResID_i]);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }
    ret = destBuf.writeCharWithNull(separator);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->Position */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Position]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->Position */
    if (0 > indent)
    {
        ret = this->Position.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->Position.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->Rotation */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Rotation]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->Rotation */
    if (0 > indent)
    {
        ret = this->Rotation.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->Rotation.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->SpawnPathID */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[SpawnPathID]", "%d", this->SpawnPathID);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->ItemDropsCnt */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[ItemDropsCnt]", "%d", this->ItemDropsCnt);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->ItemDropsList */
    for (unsigned ItemDropsList_i = 0; ItemDropsList_i < RES_PVPCONFIG_DROPITEM_NUM; ItemDropsList_i++)
    {
        ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[ItemDropsList]", ItemDropsList_i, true);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }

        /* visualize children of this->ItemDropsList[ItemDropsList_i] */
        if (0 > indent)
        {
            ret = this->ItemDropsList[ItemDropsList_i].visualize(destBuf, indent, separator);
        } else
        {
            ret = this->ItemDropsList[ItemDropsList_i].visualize(destBuf, indent + 1, separator);
        }
        if (TdrError::TDR_NO_ERROR != ret)
        {
            return ret;
        }
    }

    return ret;
}

const char*
BatchConfig::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
BatchConfig::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
GroupConfig::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
GroupConfig::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
GroupConfig::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || GroupConfig::CURRVERSION < cutVer)
    {
        cutVer = GroupConfig::CURRVERSION;
    }

    /* check cutversion */
    if (GroupConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->GroupType */
    {
        ret = destBuf.writeInt8(this->GroupType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->MonsterHardLevel */
    {
        ret = destBuf.writeInt8(this->MonsterHardLevel);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->BrithTime */
    {
        ret = destBuf.writeInt32(this->BrithTime);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->CenterPos */
    {
        ret = this->CenterPos.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->SpawnType */
    {
        ret = destBuf.writeInt32(this->SpawnType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->RefreshInterval */
    {
        ret = destBuf.writeInt32(this->RefreshInterval);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->EventNum */
    {
        ret = destBuf.writeInt8(this->EventNum);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->EventList */
    {
        for (unsigned EventList_i = 0; EventList_i < RES_PVPCONFIG_MAX_EVENT_LEN; EventList_i++)
        {
            ret = this->EventList[EventList_i].pack(destBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* pack member: this->BatchCnt */
    {
        ret = destBuf.writeInt8(this->BatchCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->BatchList */
    {
        for (unsigned BatchList_i = 0; BatchList_i < RES_PVPCONFIG_MAX_BATCH_LEN; BatchList_i++)
        {
            ret = this->BatchList[BatchList_i].pack(destBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
GroupConfig::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
GroupConfig::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || GroupConfig::CURRVERSION < cutVer)
    {
        cutVer = GroupConfig::CURRVERSION;
    }

    /* check cutversion */
    if (GroupConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->GroupType */
    {
        ret = srcBuf.readInt8(this->GroupType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->MonsterHardLevel */
    {
        ret = srcBuf.readInt8(this->MonsterHardLevel);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->BrithTime */
    {
        ret = srcBuf.readInt32(this->BrithTime);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->CenterPos */
    {
        ret = this->CenterPos.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->SpawnType */
    {
        ret = srcBuf.readInt32(this->SpawnType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->RefreshInterval */
    {
        ret = srcBuf.readInt32(this->RefreshInterval);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->EventNum */
    {
        ret = srcBuf.readInt8(this->EventNum);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->EventList */
    {
        for (unsigned EventList_i = 0; EventList_i < RES_PVPCONFIG_MAX_EVENT_LEN; EventList_i++)
        {
            ret = this->EventList[EventList_i].unpack(srcBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* unpack member: this->BatchCnt */
    {
        ret = srcBuf.readInt8(this->BatchCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->BatchList */
    {
        for (unsigned BatchList_i = 0; BatchList_i < RES_PVPCONFIG_MAX_BATCH_LEN; BatchList_i++)
        {
            ret = this->BatchList[BatchList_i].unpack(srcBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
GroupConfig::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
GroupConfig::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->GroupType */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[GroupType]", "0x%02x", this->GroupType);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->MonsterHardLevel */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[MonsterHardLevel]", "0x%02x", this->MonsterHardLevel);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->BrithTime */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[BrithTime]", "%d", this->BrithTime);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->CenterPos */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[CenterPos]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->CenterPos */
    if (0 > indent)
    {
        ret = this->CenterPos.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->CenterPos.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->SpawnType */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[SpawnType]", "%d", this->SpawnType);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->RefreshInterval */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[RefreshInterval]", "%d", this->RefreshInterval);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->EventNum */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[EventNum]", "0x%02x", this->EventNum);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->EventList */
    for (unsigned EventList_i = 0; EventList_i < RES_PVPCONFIG_MAX_EVENT_LEN; EventList_i++)
    {
        ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[EventList]", EventList_i, true);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }

        /* visualize children of this->EventList[EventList_i] */
        if (0 > indent)
        {
            ret = this->EventList[EventList_i].visualize(destBuf, indent, separator);
        } else
        {
            ret = this->EventList[EventList_i].visualize(destBuf, indent + 1, separator);
        }
        if (TdrError::TDR_NO_ERROR != ret)
        {
            return ret;
        }
    }

    /* visualize member: this->BatchCnt */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[BatchCnt]", "0x%02x", this->BatchCnt);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->BatchList */
    for (unsigned BatchList_i = 0; BatchList_i < RES_PVPCONFIG_MAX_BATCH_LEN; BatchList_i++)
    {
        ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[BatchList]", BatchList_i, true);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }

        /* visualize children of this->BatchList[BatchList_i] */
        if (0 > indent)
        {
            ret = this->BatchList[BatchList_i].visualize(destBuf, indent, separator);
        } else
        {
            ret = this->BatchList[BatchList_i].visualize(destBuf, indent + 1, separator);
        }
        if (TdrError::TDR_NO_ERROR != ret)
        {
            return ret;
        }
    }

    return ret;
}

const char*
GroupConfig::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
GroupConfig::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
SpawnTransform::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
SpawnTransform::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
SpawnTransform::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || SpawnTransform::CURRVERSION < cutVer)
    {
        cutVer = SpawnTransform::CURRVERSION;
    }

    /* check cutversion */
    if (SpawnTransform::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->Position */
    {
        ret = this->Position.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->Rotation */
    {
        ret = this->Rotation.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
SpawnTransform::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
SpawnTransform::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || SpawnTransform::CURRVERSION < cutVer)
    {
        cutVer = SpawnTransform::CURRVERSION;
    }

    /* check cutversion */
    if (SpawnTransform::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->Position */
    {
        ret = this->Position.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->Rotation */
    {
        ret = this->Rotation.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
SpawnTransform::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
SpawnTransform::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->Position */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Position]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->Position */
    if (0 > indent)
    {
        ret = this->Position.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->Position.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->Rotation */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Rotation]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->Rotation */
    if (0 > indent)
    {
        ret = this->Rotation.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->Rotation.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    return ret;
}

const char*
SpawnTransform::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
SpawnTransform::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
SpawnTpConfig::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
SpawnTpConfig::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
SpawnTpConfig::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || SpawnTpConfig::CURRVERSION < cutVer)
    {
        cutVer = SpawnTpConfig::CURRVERSION;
    }

    /* check cutversion */
    if (SpawnTpConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->MapTPPos */
    {
        ret = this->MapTPPos.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->RangeRadius */
    {
        ret = destBuf.writeInt32(this->RangeRadius);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
SpawnTpConfig::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
SpawnTpConfig::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || SpawnTpConfig::CURRVERSION < cutVer)
    {
        cutVer = SpawnTpConfig::CURRVERSION;
    }

    /* check cutversion */
    if (SpawnTpConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->MapTPPos */
    {
        ret = this->MapTPPos.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->RangeRadius */
    {
        ret = srcBuf.readInt32(this->RangeRadius);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
SpawnTpConfig::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
SpawnTpConfig::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->MapTPPos */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[MapTPPos]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->MapTPPos */
    if (0 > indent)
    {
        ret = this->MapTPPos.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->MapTPPos.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->RangeRadius */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[RangeRadius]", "%d", this->RangeRadius);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    return ret;
}

const char*
SpawnTpConfig::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
SpawnTpConfig::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
SpawnBuildTowerConfig::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
SpawnBuildTowerConfig::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
SpawnBuildTowerConfig::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || SpawnBuildTowerConfig::CURRVERSION < cutVer)
    {
        cutVer = SpawnBuildTowerConfig::CURRVERSION;
    }

    /* check cutversion */
    if (SpawnBuildTowerConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->BuildTowerPos */
    {
        for (unsigned BuildTowerPos_i = 0; BuildTowerPos_i < RES_PVPCONFIG_MAX_BUILDTOWERPOS_LEN; BuildTowerPos_i++)
        {
            ret = this->BuildTowerPos[BuildTowerPos_i].pack(destBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
SpawnBuildTowerConfig::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
SpawnBuildTowerConfig::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || SpawnBuildTowerConfig::CURRVERSION < cutVer)
    {
        cutVer = SpawnBuildTowerConfig::CURRVERSION;
    }

    /* check cutversion */
    if (SpawnBuildTowerConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->BuildTowerPos */
    {
        for (unsigned BuildTowerPos_i = 0; BuildTowerPos_i < RES_PVPCONFIG_MAX_BUILDTOWERPOS_LEN; BuildTowerPos_i++)
        {
            ret = this->BuildTowerPos[BuildTowerPos_i].unpack(srcBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
SpawnBuildTowerConfig::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
SpawnBuildTowerConfig::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->BuildTowerPos */
    for (unsigned BuildTowerPos_i = 0; BuildTowerPos_i < RES_PVPCONFIG_MAX_BUILDTOWERPOS_LEN; BuildTowerPos_i++)
    {
        ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[BuildTowerPos]", BuildTowerPos_i, true);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }

        /* visualize children of this->BuildTowerPos[BuildTowerPos_i] */
        if (0 > indent)
        {
            ret = this->BuildTowerPos[BuildTowerPos_i].visualize(destBuf, indent, separator);
        } else
        {
            ret = this->BuildTowerPos[BuildTowerPos_i].visualize(destBuf, indent + 1, separator);
        }
        if (TdrError::TDR_NO_ERROR != ret)
        {
            return ret;
        }
    }

    return ret;
}

const char*
SpawnBuildTowerConfig::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
SpawnBuildTowerConfig::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
GoldMineConfig::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
GoldMineConfig::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
GoldMineConfig::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || GoldMineConfig::CURRVERSION < cutVer)
    {
        cutVer = GoldMineConfig::CURRVERSION;
    }

    /* check cutversion */
    if (GoldMineConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->Type */
    {
        ret = destBuf.writeInt8(this->Type);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->TeamType */
    {
        ret = destBuf.writeInt8(this->TeamType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->RaceResID */
    {
        for (unsigned RaceResID_i = 0; RaceResID_i < RES_PVPCONFIG_MAX_RACE_LEN; RaceResID_i++)
        {
            ret = destBuf.writeInt32(this->RaceResID[RaceResID_i]);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* pack member: this->GodMineSpawnTransform */
    {
        ret = this->GodMineSpawnTransform.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->TpConfig */
    {
        ret = this->TpConfig.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->BuildTowerConfig */
    {
        ret = this->BuildTowerConfig.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->GuardGroupID */
    {
        ret = destBuf.writeInt32(this->GuardGroupID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->GoldMineGroupID */
    {
        ret = destBuf.writeInt32(this->GoldMineGroupID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->Interval */
    {
        ret = destBuf.writeInt32(this->Interval);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->AddGold */
    {
        ret = destBuf.writeInt32(this->AddGold);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->MaxGold */
    {
        ret = destBuf.writeInt32(this->MaxGold);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
GoldMineConfig::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
GoldMineConfig::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || GoldMineConfig::CURRVERSION < cutVer)
    {
        cutVer = GoldMineConfig::CURRVERSION;
    }

    /* check cutversion */
    if (GoldMineConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->Type */
    {
        ret = srcBuf.readInt8(this->Type);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->TeamType */
    {
        ret = srcBuf.readInt8(this->TeamType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->RaceResID */
    {
        for (unsigned RaceResID_i = 0; RaceResID_i < RES_PVPCONFIG_MAX_RACE_LEN; RaceResID_i++)
        {
            ret = srcBuf.readInt32(this->RaceResID[RaceResID_i]);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* unpack member: this->GodMineSpawnTransform */
    {
        ret = this->GodMineSpawnTransform.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->TpConfig */
    {
        ret = this->TpConfig.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->BuildTowerConfig */
    {
        ret = this->BuildTowerConfig.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->GuardGroupID */
    {
        ret = srcBuf.readInt32(this->GuardGroupID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->GoldMineGroupID */
    {
        ret = srcBuf.readInt32(this->GoldMineGroupID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->Interval */
    {
        ret = srcBuf.readInt32(this->Interval);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->AddGold */
    {
        ret = srcBuf.readInt32(this->AddGold);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->MaxGold */
    {
        ret = srcBuf.readInt32(this->MaxGold);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
GoldMineConfig::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
GoldMineConfig::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->Type */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Type]", "0x%02x", this->Type);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->TeamType */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[TeamType]", "0x%02x", this->TeamType);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->RaceResID */
    ret = TdrBufUtil::printArray(destBuf, indent, separator, "[RaceResID]", RES_PVPCONFIG_MAX_RACE_LEN);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }
    for (unsigned RaceResID_i = 0; RaceResID_i < RES_PVPCONFIG_MAX_RACE_LEN; RaceResID_i++)
    {
        ret = destBuf.textize(" ""%d", this->RaceResID[RaceResID_i]);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }
    ret = destBuf.writeCharWithNull(separator);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->GodMineSpawnTransform */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[GodMineSpawnTransform]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->GodMineSpawnTransform */
    if (0 > indent)
    {
        ret = this->GodMineSpawnTransform.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->GodMineSpawnTransform.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->TpConfig */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[TpConfig]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->TpConfig */
    if (0 > indent)
    {
        ret = this->TpConfig.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->TpConfig.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->BuildTowerConfig */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[BuildTowerConfig]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->BuildTowerConfig */
    if (0 > indent)
    {
        ret = this->BuildTowerConfig.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->BuildTowerConfig.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->GuardGroupID */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[GuardGroupID]", "%d", this->GuardGroupID);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->GoldMineGroupID */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[GoldMineGroupID]", "%d", this->GoldMineGroupID);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->Interval */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Interval]", "%d", this->Interval);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->AddGold */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[AddGold]", "%d", this->AddGold);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->MaxGold */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[MaxGold]", "%d", this->MaxGold);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    return ret;
}

const char*
GoldMineConfig::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
GoldMineConfig::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
PlayerBaseRegConfig::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
PlayerBaseRegConfig::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
PlayerBaseRegConfig::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || PlayerBaseRegConfig::CURRVERSION < cutVer)
    {
        cutVer = PlayerBaseRegConfig::CURRVERSION;
    }

    /* check cutversion */
    if (PlayerBaseRegConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->Position */
    {
        ret = this->Position.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->Radius */
    {
        ret = destBuf.writeInt32(this->Radius);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
PlayerBaseRegConfig::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
PlayerBaseRegConfig::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || PlayerBaseRegConfig::CURRVERSION < cutVer)
    {
        cutVer = PlayerBaseRegConfig::CURRVERSION;
    }

    /* check cutversion */
    if (PlayerBaseRegConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->Position */
    {
        ret = this->Position.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->Radius */
    {
        ret = srcBuf.readInt32(this->Radius);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
PlayerBaseRegConfig::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
PlayerBaseRegConfig::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->Position */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Position]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->Position */
    if (0 > indent)
    {
        ret = this->Position.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->Position.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->Radius */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Radius]", "%d", this->Radius);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    return ret;
}

const char*
PlayerBaseRegConfig::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
PlayerBaseRegConfig::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
MapPlayerConfig::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
MapPlayerConfig::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MapPlayerConfig::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || MapPlayerConfig::CURRVERSION < cutVer)
    {
        cutVer = MapPlayerConfig::CURRVERSION;
    }

    /* check cutversion */
    if (MapPlayerConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->TeamType */
    {
        ret = destBuf.writeInt8(this->TeamType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->IsFixedStartPos */
    {
        ret = destBuf.writeInt8(this->IsFixedStartPos);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->CtrType */
    {
        ret = destBuf.writeInt8(this->CtrType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->TpConfig */
    {
        ret = this->TpConfig.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->ActorSpawnTransform */
    {
        ret = this->ActorSpawnTransform.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->GoldMineIndex */
    {
        ret = destBuf.writeInt8(this->GoldMineIndex);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->GourpCnt */
    {
        ret = destBuf.writeInt8(this->GourpCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->GourpList */
    {
        for (unsigned GourpList_i = 0; GourpList_i < RES_PVPCONFIG_MAX_PLAYERGROUP_LEN; GourpList_i++)
        {
            ret = this->GourpList[GourpList_i].pack(destBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* pack member: this->BaseRegConfig */
    {
        ret = this->BaseRegConfig.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
MapPlayerConfig::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MapPlayerConfig::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || MapPlayerConfig::CURRVERSION < cutVer)
    {
        cutVer = MapPlayerConfig::CURRVERSION;
    }

    /* check cutversion */
    if (MapPlayerConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->TeamType */
    {
        ret = srcBuf.readInt8(this->TeamType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->IsFixedStartPos */
    {
        ret = srcBuf.readInt8(this->IsFixedStartPos);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->CtrType */
    {
        ret = srcBuf.readInt8(this->CtrType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->TpConfig */
    {
        ret = this->TpConfig.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->ActorSpawnTransform */
    {
        ret = this->ActorSpawnTransform.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->GoldMineIndex */
    {
        ret = srcBuf.readInt8(this->GoldMineIndex);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->GourpCnt */
    {
        ret = srcBuf.readInt8(this->GourpCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->GourpList */
    {
        for (unsigned GourpList_i = 0; GourpList_i < RES_PVPCONFIG_MAX_PLAYERGROUP_LEN; GourpList_i++)
        {
            ret = this->GourpList[GourpList_i].unpack(srcBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* unpack member: this->BaseRegConfig */
    {
        ret = this->BaseRegConfig.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
MapPlayerConfig::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MapPlayerConfig::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->TeamType */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[TeamType]", "0x%02x", this->TeamType);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->IsFixedStartPos */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[IsFixedStartPos]", "0x%02x", this->IsFixedStartPos);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->CtrType */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[CtrType]", "0x%02x", this->CtrType);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->TpConfig */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[TpConfig]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->TpConfig */
    if (0 > indent)
    {
        ret = this->TpConfig.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->TpConfig.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->ActorSpawnTransform */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[ActorSpawnTransform]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->ActorSpawnTransform */
    if (0 > indent)
    {
        ret = this->ActorSpawnTransform.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->ActorSpawnTransform.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->GoldMineIndex */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[GoldMineIndex]", "0x%02x", this->GoldMineIndex);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->GourpCnt */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[GourpCnt]", "0x%02x", this->GourpCnt);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->GourpList */
    for (unsigned GourpList_i = 0; GourpList_i < RES_PVPCONFIG_MAX_PLAYERGROUP_LEN; GourpList_i++)
    {
        ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[GourpList]", GourpList_i, true);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }

        /* visualize children of this->GourpList[GourpList_i] */
        if (0 > indent)
        {
            ret = this->GourpList[GourpList_i].visualize(destBuf, indent, separator);
        } else
        {
            ret = this->GourpList[GourpList_i].visualize(destBuf, indent + 1, separator);
        }
        if (TdrError::TDR_NO_ERROR != ret)
        {
            return ret;
        }
    }

    /* visualize member: this->BaseRegConfig */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[BaseRegConfig]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->BaseRegConfig */
    if (0 > indent)
    {
        ret = this->BaseRegConfig.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->BaseRegConfig.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    return ret;
}

const char*
MapPlayerConfig::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
MapPlayerConfig::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
MapAreaTransferConfig::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
MapAreaTransferConfig::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MapAreaTransferConfig::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || MapAreaTransferConfig::CURRVERSION < cutVer)
    {
        cutVer = MapAreaTransferConfig::CURRVERSION;
    }

    /* check cutversion */
    if (MapAreaTransferConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->TransferOutAreaID */
    {
        ret = destBuf.writeInt8(this->TransferOutAreaID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->TransferInPos */
    {
        ret = this->TransferInPos.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->TransferOutPos */
    {
        ret = this->TransferOutPos.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->TransferGroupID */
    {
        ret = destBuf.writeInt32(this->TransferGroupID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->Radius */
    {
        ret = destBuf.writeInt32(this->Radius);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->CheckTime */
    {
        ret = destBuf.writeInt32(this->CheckTime);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
MapAreaTransferConfig::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MapAreaTransferConfig::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || MapAreaTransferConfig::CURRVERSION < cutVer)
    {
        cutVer = MapAreaTransferConfig::CURRVERSION;
    }

    /* check cutversion */
    if (MapAreaTransferConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->TransferOutAreaID */
    {
        ret = srcBuf.readInt8(this->TransferOutAreaID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->TransferInPos */
    {
        ret = this->TransferInPos.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->TransferOutPos */
    {
        ret = this->TransferOutPos.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->TransferGroupID */
    {
        ret = srcBuf.readInt32(this->TransferGroupID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->Radius */
    {
        ret = srcBuf.readInt32(this->Radius);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->CheckTime */
    {
        ret = srcBuf.readInt32(this->CheckTime);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    return ret;
}

TdrError::ErrorType
MapAreaTransferConfig::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MapAreaTransferConfig::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->TransferOutAreaID */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[TransferOutAreaID]", "0x%02x", this->TransferOutAreaID);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->TransferInPos */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[TransferInPos]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->TransferInPos */
    if (0 > indent)
    {
        ret = this->TransferInPos.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->TransferInPos.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->TransferOutPos */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[TransferOutPos]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->TransferOutPos */
    if (0 > indent)
    {
        ret = this->TransferOutPos.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->TransferOutPos.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->TransferGroupID */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[TransferGroupID]", "%d", this->TransferGroupID);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->Radius */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Radius]", "%d", this->Radius);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->CheckTime */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[CheckTime]", "%d", this->CheckTime);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    return ret;
}

const char*
MapAreaTransferConfig::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
MapAreaTransferConfig::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
MapAreaConfig::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
MapAreaConfig::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MapAreaConfig::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || MapAreaConfig::CURRVERSION < cutVer)
    {
        cutVer = MapAreaConfig::CURRVERSION;
    }

    /* check cutversion */
    if (MapAreaConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->MapAreaType */
    {
        ret = destBuf.writeInt8(this->MapAreaType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->AreaID */
    {
        ret = destBuf.writeInt8(this->AreaID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->CenterPos */
    {
        ret = this->CenterPos.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->Radius */
    {
        ret = destBuf.writeInt32(this->Radius);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->TransferCnt */
    {
        ret = destBuf.writeInt8(this->TransferCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->Transfers */
    {
        for (unsigned Transfers_i = 0; Transfers_i < RES_PVPCONFIG_MAX_ARETRANSFER_LEN; Transfers_i++)
        {
            ret = this->Transfers[Transfers_i].pack(destBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
MapAreaConfig::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MapAreaConfig::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || MapAreaConfig::CURRVERSION < cutVer)
    {
        cutVer = MapAreaConfig::CURRVERSION;
    }

    /* check cutversion */
    if (MapAreaConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->MapAreaType */
    {
        ret = srcBuf.readInt8(this->MapAreaType);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->AreaID */
    {
        ret = srcBuf.readInt8(this->AreaID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->CenterPos */
    {
        ret = this->CenterPos.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->Radius */
    {
        ret = srcBuf.readInt32(this->Radius);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->TransferCnt */
    {
        ret = srcBuf.readInt8(this->TransferCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->Transfers */
    {
        for (unsigned Transfers_i = 0; Transfers_i < RES_PVPCONFIG_MAX_ARETRANSFER_LEN; Transfers_i++)
        {
            ret = this->Transfers[Transfers_i].unpack(srcBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
MapAreaConfig::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MapAreaConfig::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->MapAreaType */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[MapAreaType]", "0x%02x", this->MapAreaType);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->AreaID */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[AreaID]", "0x%02x", this->AreaID);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->CenterPos */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[CenterPos]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->CenterPos */
    if (0 > indent)
    {
        ret = this->CenterPos.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->CenterPos.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->Radius */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Radius]", "%d", this->Radius);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->TransferCnt */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[TransferCnt]", "0x%02x", this->TransferCnt);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->Transfers */
    for (unsigned Transfers_i = 0; Transfers_i < RES_PVPCONFIG_MAX_ARETRANSFER_LEN; Transfers_i++)
    {
        ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[Transfers]", Transfers_i, true);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }

        /* visualize children of this->Transfers[Transfers_i] */
        if (0 > indent)
        {
            ret = this->Transfers[Transfers_i].visualize(destBuf, indent, separator);
        } else
        {
            ret = this->Transfers[Transfers_i].visualize(destBuf, indent + 1, separator);
        }
        if (TdrError::TDR_NO_ERROR != ret)
        {
            return ret;
        }
    }

    return ret;
}

const char*
MapAreaConfig::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
MapAreaConfig::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
MapNeutralConfig::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
MapNeutralConfig::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MapNeutralConfig::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || MapNeutralConfig::CURRVERSION < cutVer)
    {
        cutVer = MapNeutralConfig::CURRVERSION;
    }

    /* check cutversion */
    if (MapNeutralConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->GourpCnt */
    {
        ret = destBuf.writeInt8(this->GourpCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->GourpList */
    {
        for (unsigned GourpList_i = 0; GourpList_i < RES_PVPCONFIG_MAX_GROUP_LEN; GourpList_i++)
        {
            ret = this->GourpList[GourpList_i].pack(destBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* pack member: this->GoldMineCnt */
    {
        ret = destBuf.writeInt8(this->GoldMineCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->GoldMineList */
    {
        for (unsigned GoldMineList_i = 0; GoldMineList_i < RES_PVPCONFIG_GOLDMINE_MAX_NUM; GoldMineList_i++)
        {
            ret = this->GoldMineList[GoldMineList_i].pack(destBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* pack member: this->AreaCnt */
    {
        ret = destBuf.writeInt8(this->AreaCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->AreaConfigs */
    {
        for (unsigned AreaConfigs_i = 0; AreaConfigs_i < RES_PVPCONFIG_MAX_MAPAREA_LEN; AreaConfigs_i++)
        {
            ret = this->AreaConfigs[AreaConfigs_i].pack(destBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
MapNeutralConfig::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MapNeutralConfig::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || MapNeutralConfig::CURRVERSION < cutVer)
    {
        cutVer = MapNeutralConfig::CURRVERSION;
    }

    /* check cutversion */
    if (MapNeutralConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->GourpCnt */
    {
        ret = srcBuf.readInt8(this->GourpCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->GourpList */
    {
        for (unsigned GourpList_i = 0; GourpList_i < RES_PVPCONFIG_MAX_GROUP_LEN; GourpList_i++)
        {
            ret = this->GourpList[GourpList_i].unpack(srcBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* unpack member: this->GoldMineCnt */
    {
        ret = srcBuf.readInt8(this->GoldMineCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->GoldMineList */
    {
        for (unsigned GoldMineList_i = 0; GoldMineList_i < RES_PVPCONFIG_GOLDMINE_MAX_NUM; GoldMineList_i++)
        {
            ret = this->GoldMineList[GoldMineList_i].unpack(srcBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* unpack member: this->AreaCnt */
    {
        ret = srcBuf.readInt8(this->AreaCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->AreaConfigs */
    {
        for (unsigned AreaConfigs_i = 0; AreaConfigs_i < RES_PVPCONFIG_MAX_MAPAREA_LEN; AreaConfigs_i++)
        {
            ret = this->AreaConfigs[AreaConfigs_i].unpack(srcBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
MapNeutralConfig::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MapNeutralConfig::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->GourpCnt */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[GourpCnt]", "0x%02x", this->GourpCnt);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->GourpList */
    for (unsigned GourpList_i = 0; GourpList_i < RES_PVPCONFIG_MAX_GROUP_LEN; GourpList_i++)
    {
        ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[GourpList]", GourpList_i, true);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }

        /* visualize children of this->GourpList[GourpList_i] */
        if (0 > indent)
        {
            ret = this->GourpList[GourpList_i].visualize(destBuf, indent, separator);
        } else
        {
            ret = this->GourpList[GourpList_i].visualize(destBuf, indent + 1, separator);
        }
        if (TdrError::TDR_NO_ERROR != ret)
        {
            return ret;
        }
    }

    /* visualize member: this->GoldMineCnt */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[GoldMineCnt]", "0x%02x", this->GoldMineCnt);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->GoldMineList */
    for (unsigned GoldMineList_i = 0; GoldMineList_i < RES_PVPCONFIG_GOLDMINE_MAX_NUM; GoldMineList_i++)
    {
        ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[GoldMineList]", GoldMineList_i, true);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }

        /* visualize children of this->GoldMineList[GoldMineList_i] */
        if (0 > indent)
        {
            ret = this->GoldMineList[GoldMineList_i].visualize(destBuf, indent, separator);
        } else
        {
            ret = this->GoldMineList[GoldMineList_i].visualize(destBuf, indent + 1, separator);
        }
        if (TdrError::TDR_NO_ERROR != ret)
        {
            return ret;
        }
    }

    /* visualize member: this->AreaCnt */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[AreaCnt]", "0x%02x", this->AreaCnt);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->AreaConfigs */
    for (unsigned AreaConfigs_i = 0; AreaConfigs_i < RES_PVPCONFIG_MAX_MAPAREA_LEN; AreaConfigs_i++)
    {
        ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[AreaConfigs]", AreaConfigs_i, true);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }

        /* visualize children of this->AreaConfigs[AreaConfigs_i] */
        if (0 > indent)
        {
            ret = this->AreaConfigs[AreaConfigs_i].visualize(destBuf, indent, separator);
        } else
        {
            ret = this->AreaConfigs[AreaConfigs_i].visualize(destBuf, indent + 1, separator);
        }
        if (TdrError::TDR_NO_ERROR != ret)
        {
            return ret;
        }
    }

    return ret;
}

const char*
MapNeutralConfig::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
MapNeutralConfig::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


TdrError::ErrorType
MobaPvpConfig::construct()
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    memset(this, 0, sizeof(*this));

    return ret;
}

TdrError::ErrorType
MobaPvpConfig::pack(char* buffer, size_t size, size_t* usedSize, unsigned cutVer) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = pack(destBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MobaPvpConfig::pack(TdrWriteBuf& destBuf, unsigned cutVer) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || MobaPvpConfig::CURRVERSION < cutVer)
    {
        cutVer = MobaPvpConfig::CURRVERSION;
    }

    /* check cutversion */
    if (MobaPvpConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* pack member: this->ResID */
    {
        ret = destBuf.writeInt32(this->ResID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->PathCnt */
    {
        ret = destBuf.writeInt8(this->PathCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->PathList */
    {
        for (unsigned PathList_i = 0; PathList_i < RES_PVPCONFIG_MAX_PATHLIST_LEN; PathList_i++)
        {
            ret = this->PathList[PathList_i].pack(destBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* pack member: this->NeutralConfig */
    {
        ret = this->NeutralConfig.pack(destBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->PlayerNum */
    {
        ret = destBuf.writeInt8(this->PlayerNum);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* pack member: this->PlayerConfigs */
    {
        for (unsigned PlayerConfigs_i = 0; PlayerConfigs_i < RES_PVPCONFIG_MAX_RACERITH_LEN; PlayerConfigs_i++)
        {
            ret = this->PlayerConfigs[PlayerConfigs_i].pack(destBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
MobaPvpConfig::unpack(const char* buffer, size_t size, size_t* usedSize, unsigned cutVer)
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrReadBuf srcBuf(buffer, size);
    TdrError::ErrorType ret = unpack(srcBuf, cutVer);
    if (NULL != usedSize)
    {
        *usedSize = srcBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MobaPvpConfig::unpack(TdrReadBuf& srcBuf, unsigned cutVer)
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* adjust cutversion */
    if (0 == cutVer || MobaPvpConfig::CURRVERSION < cutVer)
    {
        cutVer = MobaPvpConfig::CURRVERSION;
    }

    /* check cutversion */
    if (MobaPvpConfig::BASEVERSION > cutVer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_CUTVER_TOO_SMALL;
    }

    /* unpack member: this->ResID */
    {
        ret = srcBuf.readInt32(this->ResID);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->PathCnt */
    {
        ret = srcBuf.readInt8(this->PathCnt);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->PathList */
    {
        for (unsigned PathList_i = 0; PathList_i < RES_PVPCONFIG_MAX_PATHLIST_LEN; PathList_i++)
        {
            ret = this->PathList[PathList_i].unpack(srcBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    /* unpack member: this->NeutralConfig */
    {
        ret = this->NeutralConfig.unpack(srcBuf, cutVer);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->PlayerNum */
    {
        ret = srcBuf.readInt8(this->PlayerNum);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }
    }

    /* unpack member: this->PlayerConfigs */
    {
        for (unsigned PlayerConfigs_i = 0; PlayerConfigs_i < RES_PVPCONFIG_MAX_RACERITH_LEN; PlayerConfigs_i++)
        {
            ret = this->PlayerConfigs[PlayerConfigs_i].unpack(srcBuf, cutVer);
            if (TdrError::TDR_NO_ERROR != ret)
            {
                TSF4G_TDR_DEBUG_TRACE();
                return ret;
            }
        }
    }

    return ret;
}

TdrError::ErrorType
MobaPvpConfig::visualize(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    TdrWriteBuf destBuf(buffer, size);
    TdrError::ErrorType ret = visualize(destBuf, indent, separator);
    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return ret;
}

TdrError::ErrorType
MobaPvpConfig::visualize(TdrWriteBuf& destBuf, int indent, char separator) const
{
    TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

    /* visualize member: this->ResID */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[ResID]", "%d", this->ResID);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->PathCnt */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[PathCnt]", "0x%02x", this->PathCnt);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->PathList */
    for (unsigned PathList_i = 0; PathList_i < RES_PVPCONFIG_MAX_PATHLIST_LEN; PathList_i++)
    {
        ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[PathList]", PathList_i, true);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }

        /* visualize children of this->PathList[PathList_i] */
        if (0 > indent)
        {
            ret = this->PathList[PathList_i].visualize(destBuf, indent, separator);
        } else
        {
            ret = this->PathList[PathList_i].visualize(destBuf, indent + 1, separator);
        }
        if (TdrError::TDR_NO_ERROR != ret)
        {
            return ret;
        }
    }

    /* visualize member: this->NeutralConfig */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[NeutralConfig]", true);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize children of this->NeutralConfig */
    if (0 > indent)
    {
        ret = this->NeutralConfig.visualize(destBuf, indent, separator);
    } else
    {
        ret = this->NeutralConfig.visualize(destBuf, indent + 1, separator);
    }
    if (TdrError::TDR_NO_ERROR != ret)
    {
        return ret;
    }

    /* visualize member: this->PlayerNum */
    ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[PlayerNum]", "0x%02x", this->PlayerNum);
    if (TdrError::TDR_NO_ERROR != ret)
    {
        TSF4G_TDR_DEBUG_TRACE();
        return ret;
    }

    /* visualize member: this->PlayerConfigs */
    for (unsigned PlayerConfigs_i = 0; PlayerConfigs_i < RES_PVPCONFIG_MAX_RACERITH_LEN; PlayerConfigs_i++)
    {
        ret = TdrBufUtil::printVariable(destBuf, indent, separator, "[PlayerConfigs]", PlayerConfigs_i, true);
        if (TdrError::TDR_NO_ERROR != ret)
        {
            TSF4G_TDR_DEBUG_TRACE();
            return ret;
        }

        /* visualize children of this->PlayerConfigs[PlayerConfigs_i] */
        if (0 > indent)
        {
            ret = this->PlayerConfigs[PlayerConfigs_i].visualize(destBuf, indent, separator);
        } else
        {
            ret = this->PlayerConfigs[PlayerConfigs_i].visualize(destBuf, indent + 1, separator);
        }
        if (TdrError::TDR_NO_ERROR != ret)
        {
            return ret;
        }
    }

    return ret;
}

const char*
MobaPvpConfig::visualize_ex(char* buffer, size_t size, size_t* usedSize, int indent, char separator) const
{
    if (NULL == buffer || 0 == size)
    {
        return "";
    }

    TdrWriteBuf destBuf(buffer, size);
    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = size;
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    buffer[targetPos] = '\0';

    if (NULL != usedSize)
    {
        *usedSize = destBuf.getUsedSize();
    }

    return destBuf.getBeginPtr();
}

const char*
MobaPvpConfig::visualize_ex(TdrWriteBuf& destBuf, int indent, char separator) const
{
    if (NULL == destBuf.getBeginPtr() || 0 == destBuf.getTotalSize())
    {
        return "";
    }

    visualize(destBuf, indent, separator);

    size_t targetPos = destBuf.getUsedSize();
    const size_t totalSize = destBuf.getTotalSize();
    if (totalSize <= targetPos)
    {
        targetPos = totalSize - 1;
    }
    destBuf.writeChar('\0', targetPos);

    return destBuf.getBeginPtr();
}


}
